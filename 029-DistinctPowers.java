/*
 * Consider all integer combinations of a^b for 2 ≤ a ≤ 5 and 2 ≤ b ≤ 5:
 * 2^2=4, 2^3=8, 2^4=16, 2^5=32
 * 3^2=9, 3^3=27, 3^4=81, 3^5=243
 * 4^2=16, 4^3=64, 4^4=256, 4^5=1024
 * 5^2=25, 5^3=125, 5^4=625, 5^5=3125
 * If they are then placed in numerical order, with any repeats removed, we get the following sequence of 15 distinct terms:
 * 
 * 4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125
 * 
 * How many distinct terms are in the sequence generated by a^b for 2 ≤ a ≤ 100 and 2 ≤ b ≤ 100?
 * 
 * */

//this code uses PrimeRepresentation objects. Class code in comment below.  

import java.util.ArrayList;
import java.util.HashSet;

public class N029DistinctPowers {
	
	public static ArrayList<Integer> getPrimesUpTo (int n) {
		boolean[] sieve = new boolean[n+1];
		sieve[0] = true;
		sieve[1] = true;
		for (int i = 4; i < sieve.length; i = i +2) {
			sieve[i] = true;
		}
		for (int i = 3; i <= (int)Math.sqrt(n); i = i +2) {
			if (!sieve[i]) {
				for (int j = i*i; j < sieve.length; j = j + 2*i) {
					sieve[j] = true;
				}
			}
		}	
		ArrayList<Integer> primes = new ArrayList<Integer>();
		for (int i = 2; i < sieve.length ;i++) {
			if (!sieve[i]) {
				primes.add(i);
			}
		}
		return primes;	
	}
	
	public static int[] getPrimeFactorExponentsFor (int n, ArrayList<Integer> primes) {		
		int[] exps = new int[primes.size()];		
		for (int i = 0; i < primes.size(); i++) {			
			if(n % primes.get(i) == 0) {
				int exp = 0;
				while (n % primes.get(i) == 0) {
					exp++;
					n = n/primes.get(i);
				}
				exps[i] = exp;
			}
		}
		return exps;
	}
	
	public static int[] raiseBaseExponentsByExponent (int base, int exp, ArrayList<Integer> primes) {
		int[] exponents = getPrimeFactorExponentsFor(base, primes);
		for (int i = 0; i < exponents.length; i++) {
			exponents[i] *= exp;
		}
		return exponents;
	}
	
	public static void main(String[] args) {	
		
		long start = System.nanoTime();
		int base = 100, exp = 100;
		ArrayList<Integer> primes = getPrimesUpTo(base);
		HashSet<PrimeRepresentation> powers = new HashSet<PrimeRepresentation>();
		for (int a = 2; a <= base; a++) {
			for (int b = 2; b <= exp; b++) {
				PrimeRepresentation power = new PrimeRepresentation(raiseBaseExponentsByExponent (a, b, primes));
				powers.add(power);
			}
		}
		System.out.println(powers.size());		
		long end = System.nanoTime();
		System.out.println("Execution time: " + ((end - start) / 1e+6) + " ms");
	}
}

/*
import java.util.Arrays;

//this class represents a positive integer n as an array of
//prime factor exponents. When n is factored into primes, the
//exponents of the i-th prime (which may be 0) is held in the (i-1)-th array index.

public class PrimeRepresentation {
	
	private final int[] exponents;
	
	PrimeRepresentation (int [] exponents) {
		this.exponents = exponents;
	}
	
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + Arrays.hashCode(exponents);
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		PrimeRepresentation other = (PrimeRepresentation) obj;
		if (!Arrays.equals(exponents, other.exponents))
			return false;
		return true;
	}
	
	
}

*/
